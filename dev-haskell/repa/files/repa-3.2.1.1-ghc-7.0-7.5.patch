--- repa-3.2.1.1-orig/repa.cabal	2012-06-05 23:08:49.000000000 +1000
+++ repa-3.2.1.1/repa.cabal	2012-07-08 12:37:22.640074228 +1000
@@ -26,8 +26,8 @@
         base                 == 4.*,
         ghc-prim             == 0.2.*,
         vector               == 0.9.*,
-        bytestring           == 0.9.*,
-        QuickCheck           >= 2.3 && < 2.5,
+        bytestring           >= 0.9 && < 0.11,
+        QuickCheck           >= 2.3 && < 2.6,
         template-haskell     >= 2.5 && < 2.8
 
   ghc-options:
--- repa-3.2.1.1-orig/Data/Array/Repa/Eval/Gang.hs	2012-06-05 23:08:49.000000000 +1000
+++ repa-3.2.1.1/Data/Array/Repa/Eval/Gang.hs	2012-07-08 12:36:39.921220501 +1000
@@ -7,14 +7,17 @@
 where
 import GHC.IO
 import GHC.ST
+#if MIN_VERSION_base(4,4,0)
 import GHC.Conc                 (forkOn)
+#else
+import GHC.Conc                 (forkOnIO)
+#endif
 import Control.Concurrent.MVar
 import Control.Exception        (assert)
 import Control.Monad
 import GHC.Conc			(numCapabilities)
 import System.IO
 
-
 -- TheGang --------------------------------------------------------------------
 -- | This globally shared gang is auto-initialised at startup and shared by all
 --   Repa computations.
@@ -105,7 +108,12 @@
                 mvsDone
 
         -- Create all the worker threads
-        zipWithM_ forkOn [0..]
+        zipWithM_ 
+#if MIN_VERSION_base(4,4,0)
+            forkOn [0..]
+#else
+            forkOnIO [0..]
+#endif
                 $ zipWith3 gangWorker 
                         [0 .. n-1] mvsRequest mvsDone
 
--- repa-3.2.1.1-orig/Data/Array/Repa/Repr/ForeignPtr.hs	2012-06-05 23:08:49.000000000 +1000
+++ repa-3.2.1.1/Data/Array/Repa/Repr/ForeignPtr.hs	2012-07-08 12:36:39.922220515 +1000
@@ -1,3 +1,4 @@
+{-# LANGUAGE CPP #-}
 
 module Data.Array.Repa.Repr.ForeignPtr
         ( F, Array (..)
@@ -13,7 +14,11 @@
 import Foreign.ForeignPtr
 import Foreign.Marshal.Alloc
 import System.IO.Unsafe
+#if MIN_VERSION_base(4,4,0)
 import qualified Foreign.ForeignPtr.Unsafe      as Unsafe
+#else
+import qualified Foreign.ForeignPtr as Unsafe
+#endif
 
 -- | Arrays represented as foreign buffers in the C heap.
 data F
--- repa-3.2.1.1-orig/Data/Array/Repa/Repr/HintInterleave.hs	2012-06-05 23:08:49.000000000 +1000
+++ repa-3.2.1.1/Data/Array/Repa/Repr/HintInterleave.hs	2012-07-08 12:36:39.923220530 +1000
@@ -1,4 +1,4 @@
-
+{-# LANGUAGE CPP #-}
 module Data.Array.Repa.Repr.HintInterleave
         (I, Array (..), hintInterleave)
 where
@@ -10,6 +10,10 @@
 import Data.Array.Repa.Base
 import Debug.Trace
 
+#if !MIN_VERSION_base(4,4,0)
+traceEventIO :: String -> IO ()
+traceEventIO = putTraceMsg
+#endif
 
 -- | Hints that computing this array will be an unbalanced workload
 --   and evaluation should be interleaved between the processors.
--- repa-3.2.1.1-orig/Data/Array/Repa/Repr/Cursored.hs	2012-06-05 23:08:49.000000000 +1000
+++ repa-3.2.1.1/Data/Array/Repa/Repr/Cursored.hs	2012-07-08 12:36:39.923220530 +1000
@@ -1,4 +1,4 @@
-{-# LANGUAGE MagicHash #-}
+{-# LANGUAGE MagicHash, CPP, TypeSynonymInstances #-}
 module Data.Array.Repa.Repr.Cursored
         ( C, Array (..)
         , makeCursored)
@@ -15,6 +15,11 @@
 import GHC.Exts
 import Debug.Trace
 
+#if !MIN_VERSION_base(4,4,0)
+traceEventIO :: String -> IO ()
+traceEventIO = putTraceMsg
+#endif
+
 -- | Cursored Arrays.
 --   These are produced by Repa's stencil functions, and help the fusion
 --   framework to share index compuations between array elements.
--- repa-3.2.1.1-orig/Data/Array/Repa/Repr/Delayed.hs	2012-06-05 23:08:49.000000000 +1000
+++ repa-3.2.1.1/Data/Array/Repa/Repr/Delayed.hs	2012-07-08 12:36:39.924220544 +1000
@@ -1,4 +1,4 @@
-{-# LANGUAGE MagicHash #-}
+{-# LANGUAGE MagicHash, CPP, TypeSynonymInstances #-}
 module Data.Array.Repa.Repr.Delayed
         ( D, Array(..)
         , fromFunction, toFunction
@@ -15,6 +15,11 @@
 import Debug.Trace
 import GHC.Exts
 
+#if !MIN_VERSION_base(4,4,0)
+traceEventIO :: String -> IO ()
+traceEventIO = putTraceMsg
+#endif
+
 -- | Delayed arrays are represented as functions from the index to element value.
 --
 --   Every time you index into a delayed array the element at that position 
