--- http-enumerator-0.6.5.5-orig/Network/HTTP/Enumerator.hs	2011-06-30 22:23:43.000000000 +1000
+++ http-enumerator-0.6.5.5/Network/HTTP/Enumerator.hs	2011-07-02 02:11:55.793985957 +1000
@@ -118,6 +118,40 @@
 import qualified Data.ByteString.Base64 as B64
 import System.IO (hClose, hFlush)
 import Blaze.ByteString.Builder (toByteString)
+#if !MIN_VERSION_base(4,3,0)
+import GHC.IO.Handle.Types
+import System.IO                (hWaitForInput, hIsEOF)
+import System.IO.Error          (mkIOError, illegalOperationErrorType)
+
+-- | Like 'hGet', except that a shorter 'ByteString' may be returned
+-- if there are not enough bytes immediately available to satisfy the
+-- whole request.  'hGetSome' only blocks if there is no data
+-- available, and EOF has not yet been reached.
+--
+hGetSome :: Handle -> Int -> IO S.ByteString
+hGetSome hh i
+    | i >  0    = let
+                   loop = do
+                     s <- S.hGetNonBlocking hh i
+                     if not (S.null s)
+                        then return s
+                        else do eof <- hIsEOF hh
+                                if eof then return s
+                                       else hWaitForInput hh (-1) >> loop
+                                         -- for this to work correctly, the
+                                         -- Handle should be in binary mode
+                                         -- (see GHC ticket #3808)
+                  in loop
+    | i == 0    = return S.empty
+    | otherwise = illegalBufferSize hh "hGetSome" i
+
+illegalBufferSize :: Handle -> String -> Int -> IO a
+illegalBufferSize handle fn sz =
+    ioError (mkIOError illegalOperationErrorType msg (Just handle) Nothing)
+    --TODO: System.IO uses InvalidArgument here, but it's not exported :-(
+    where
+      msg = fn ++ ": illegal ByteString size " ++ showsPrec 9 sz []
+#endif
 
 getSocket :: String -> Int -> IO NS.Socket
 getSocket host' port' = do
@@ -188,7 +222,11 @@
         h <- connectTo phost (PortNumber $ fromIntegral pport)
         S8.hPutStr h $ toByteString connectRequest
         hFlush h
+#if MIN_VERSION_base(4,3,0)
         r <- S.hGetSome h 2048
+#else
+        r <- hGetSome h 2048
+#endif
         res <- parserHeadersFromByteString r
         case res of
             Right ((_, 200, _), _) -> return h
