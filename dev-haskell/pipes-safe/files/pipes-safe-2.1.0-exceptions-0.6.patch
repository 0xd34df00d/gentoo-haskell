diff --git a/src/Pipes/Safe.hs b/src/Pipes/Safe.hs
index 594a6dd..c5327a1 100644
--- a/src/Pipes/Safe.hs
+++ b/src/Pipes/Safe.hs
@@ -1,4 +1,5 @@
 {-# LANGUAGE RankNTypes, TypeFamilies, FlexibleContexts, ScopedTypeVariables #-}
+{-# LANGUAGE CPP #-}
 {-# OPTIONS_GHC -fno-warn-orphans #-}
 
 {-| This module provides an orphan 'MonadCatch' instance for 'Proxy' of the
@@ -88,6 +89,9 @@ import Control.Exception(Exception(..), SomeException(..))
 import qualified Control.Monad.Catch as C
 import Control.Monad.Catch
     ( MonadCatch(..)
+#if MIN_VERSION_exceptions(0,6,0)
+    , MonadMask(..)
+#endif
     , MonadThrow(..)
     , mask_
     , uninterruptibleMask_
@@ -167,6 +171,9 @@ instance MonadThrow m => MonadThrow (Proxy a' a b' b m) where
 
 instance (MonadCatch m, MonadIO m) => MonadCatch (Proxy a' a b' b m) where
     catch  = liftCatchError C.catch
+#if MIN_VERSION_exceptions(0,6,0)
+instance (MonadMask m, MonadIO m) => MonadMask (Proxy a' a b' b m) where
+#endif
     mask                = liftMask mask
     uninterruptibleMask = liftMask uninterruptibleMask
 
@@ -215,6 +222,9 @@ instance MonadThrow m => MonadThrow (SafeT m) where
 -- Deriving 'MonadCatch'
 instance (MonadCatch m) => MonadCatch (SafeT m) where
     m `catch` f = SafeT (unSafeT m `C.catch` \r -> unSafeT (f r))
+#if MIN_VERSION_exceptions(0,6,0)
+instance (MonadMask m) => MonadMask (SafeT m) where
+#endif
     mask k = SafeT (mask (\restore ->
         unSafeT (k (\ma -> SafeT (restore (unSafeT ma)))) ))
     uninterruptibleMask k = SafeT (uninterruptibleMask (\restore ->
@@ -226,7 +236,12 @@ instance MonadTrans SafeT where
 {-| Run the 'SafeT' monad transformer, executing all unreleased finalizers at
     the end of the computation
 -}
-runSafeT :: (MonadCatch m, MonadIO m) => SafeT m r -> m r
+runSafeT :: ( MonadCatch m
+            , MonadIO m
+#if MIN_VERSION_exceptions(0,6,0)
+            , MonadMask m
+#endif
+            ) => SafeT m r -> m r
 runSafeT m = C.bracket
     (liftIO $ newIORef $! Finalizers 0 M.empty)
     (\ioref -> do
@@ -241,7 +256,12 @@ runSafeT m = C.bracket
     Use 'runSafeP' to safely flush all unreleased finalizers and ensure prompt
     finalization without exiting the 'Proxy' monad.
 -}
-runSafeP :: (MonadCatch m, MonadIO m) => Effect (SafeT m) r -> Effect' m r
+runSafeP :: ( MonadCatch m
+#if MIN_VERSION_exceptions(0,6,0)
+            , MonadMask m
+#endif
+            , MonadIO m
+            ) => Effect (SafeT m) r -> Effect' m r
 runSafeP = lift . runSafeT . runEffect
 {-# INLINABLE runSafeP #-}
 
@@ -251,7 +271,12 @@ newtype ReleaseKey = ReleaseKey { unlock :: Integer }
 {-| 'MonadSafe' lets you 'register' and 'release' finalizers that execute in a
     'Base' monad
 -}
-class (MonadCatch m, MonadIO m, MonadIO (Base m)) => MonadSafe m where
+class (MonadCatch m
+      , MonadIO m
+#if MIN_VERSION_exceptions(0,6,0)
+      , MonadMask m
+#endif
+      , MonadIO (Base m)) => MonadSafe m where
     {-| The monad used to run resource management actions, corresponding to the
         monad directly beneath 'SafeT'
     -}
@@ -273,7 +298,12 @@ class (MonadCatch m, MonadIO m, MonadIO (Base m)) => MonadSafe m where
     -}
     release  :: ReleaseKey -> m ()
 
-instance (MonadIO m, MonadCatch m) => MonadSafe (SafeT m) where
+instance (MonadIO m
+         , MonadCatch m
+#if MIN_VERSION_exceptions(0,6,0)
+         , MonadMask m
+#endif
+         ) => MonadSafe (SafeT m) where
     type Base (SafeT m) = m
 
     liftBase = lift
