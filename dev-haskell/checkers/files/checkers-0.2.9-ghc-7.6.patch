diff --git a/src/Test/QuickCheck/Classes.hs b/src/Test/QuickCheck/Classes.hs
index bb38b69..9a34a4f 100644
--- a/src/Test/QuickCheck/Classes.hs
+++ b/src/Test/QuickCheck/Classes.hs
@@ -431,20 +431,20 @@ monadOr = const ( "MonadOr laws"
    leftCatchP a b = return a `mplus` b =-= return a
 
 
-arrow :: forall (~>) b c d e.
-         ( Arrow (~>)
-         , Show (d ~> e), Show (c ~> d), Show (b ~> c)
+arrow :: forall arr b c d e.
+         ( Arrow arr
+         , Show (d `arr` e), Show (c `arr` d), Show (b `arr` c)
          , Show b, Show c, Show d, Show e
-         , Arbitrary (d ~> e), Arbitrary (c ~> d), Arbitrary (b ~> c)
+         , Arbitrary (d `arr` e), Arbitrary (c `arr` d), Arbitrary (b `arr` c)
          , Arbitrary b, Arbitrary c, Arbitrary d, Arbitrary e
          , CoArbitrary b, CoArbitrary c, CoArbitrary d
-         , EqProp (b ~> e), EqProp (b ~> d)
-         , EqProp ((b,d) ~> c)
-         , EqProp ((b,d) ~> (c,d)), EqProp ((b,e) ~> (d,e))
-         , EqProp ((b,d) ~> (c,e))
+         , EqProp (b `arr` e), EqProp (b `arr` d)
+         , EqProp ((b,d) `arr` c)
+         , EqProp ((b,d) `arr` (c,d)), EqProp ((b,e) `arr` (d,e))
+         , EqProp ((b,d) `arr` (c,e))
          , EqProp b, EqProp c, EqProp d, EqProp e
          ) =>
-         b ~> (c,d,e) -> TestBatch
+         b `arr` (c,d,e) -> TestBatch
 arrow = const ("arrow laws"
               , [ ("associativity"           , property assocP)
                 , ("arr distributes"         , property arrDistributesP)
@@ -458,37 +458,37 @@ arrow = const ("arrow laws"
                  ]
               )
   where
-    assocP :: b ~> c -> c ~> d -> d ~> e -> Property
+    assocP :: b `arr` c -> c `arr` d -> d `arr` e -> Property
     assocP f g h = ((f >>> g) >>> h) =-= (f >>> (g >>> h))
     
     arrDistributesP :: (b -> c) -> (c -> d) -> Property
-    arrDistributesP f g = ((arr (f >>> g)) :: b ~> d) =-= (arr f >>> arr g)
+    arrDistributesP f g = ((arr (f >>> g)) :: b `arr` d) =-= (arr f >>> arr g)
     
     firstAsFunP :: (b -> c) -> Property
-    firstAsFunP f = (first (arr f) :: (b,d) ~> (c,d)) =-= arr (first f)
+    firstAsFunP f = (first (arr f) :: (b,d) `arr` (c,d)) =-= arr (first f)
 
-    firstKeepCompP :: b ~> c -> c ~> d -> Property
+    firstKeepCompP :: b `arr` c -> c `arr` d -> Property
     firstKeepCompP f g =
-      ((first (f >>> g)) :: ((b,e) ~> (d,e))) =-= (first f >>> first g)
+      ((first (f >>> g)) :: ((b,e) `arr` (d,e))) =-= (first f >>> first g)
  
-    firstIsFstP :: b ~> c -> Property
-    firstIsFstP f = ((first f :: (b,d) ~> (c,d)) >>> arr fst)
+    firstIsFstP :: b `arr` c -> Property
+    firstIsFstP f = ((first f :: (b,d) `arr` (c,d)) >>> arr fst)
                       =-= (arr fst >>> f)
     
-    secondMovesP :: (b ~> c) -> (d -> e) -> Property
+    secondMovesP :: (b `arr` c) -> (d -> e) -> Property
     secondMovesP f g = (first f >>> second (arr g))
                          =-= ((second (arr g)) >>> first f)
 
-arrowChoice :: forall (~>) b c d e.
-               ( ArrowChoice (~>)
-               , Show (b ~> c)
-               , Arbitrary (b ~> c)
+arrowChoice :: forall arr b c d e.
+               ( ArrowChoice arr
+               , Show (b `arr` c)
+               , Arbitrary (b `arr` c)
                , Arbitrary b, Arbitrary c, Arbitrary d, Arbitrary e
                , CoArbitrary b, CoArbitrary d
-               , EqProp ((Either b d) ~> (Either c e))
-               , EqProp ((Either b d) ~> (Either c d))
+               , EqProp ((Either b d) `arr` (Either c e))
+               , EqProp ((Either b d) `arr` (Either c d))
                ) =>
-               b ~> (c,d,e) -> TestBatch
+               b `arr` (c,d,e) -> TestBatch
 arrowChoice = const ("arrow choice laws"
                     , [ ("left works as funs", property leftAsFunP)
                       , ("right can move"    , property rightMovesP)
@@ -496,10 +496,10 @@ arrowChoice = const ("arrow choice laws"
                     )
   where
     leftAsFunP :: (b -> c) -> Property
-    leftAsFunP f = (left (arr f) :: (Either b d) ~> (Either c d))
+    leftAsFunP f = (left (arr f) :: (Either b d) `arr` (Either c d))
                      =-= arr (left f)
 
-    rightMovesP :: (b ~> c) -> (d -> e) -> Property
+    rightMovesP :: (b `arr` c) -> (d -> e) -> Property
     rightMovesP f g = (left f >>> right (arr g))
                         =-= ((right (arr g)) >>> left f)
 
