From 91b2b40136a77252617e50adeffdca7c5978337e Mon Sep 17 00:00:00 2001
From: osa1 <omeragacan@gmail.com>
Date: Wed, 10 Sep 2014 07:30:44 +0300
Subject: [PATCH 1/2] make Alex instances of Functor and Applicative

---
 templates/wrappers.hs | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/templates/wrappers.hs b/templates/wrappers.hs
index 206915a..a1a1a6d 100644
--- a/templates/wrappers.hs
+++ b/templates/wrappers.hs
@@ -4,6 +4,7 @@
 -- This code is in the PUBLIC DOMAIN; you may copy it freely and use
 -- it for any purpose whatsoever.
 
+import Control.Applicative (Applicative (..))
 import Data.Word (Word8)
 #if defined(ALEX_BASIC_BYTESTRING) || defined(ALEX_POSN_BYTESTRING) || defined(ALEX_MONAD_BYTESTRING)
 
@@ -173,6 +174,19 @@ runAlex input (Alex f)
 
 newtype Alex a = Alex { unAlex :: AlexState -> Either String (AlexState, a) }
 
+instance Functor Alex where
+  fmap f a = Alex $ \s -> case unAlex a s of
+                            Left msg -> Left msg
+                            Right (s', a') -> Right (s', f a')
+
+instance Applicative Alex where
+  pure a   = Alex $ \s -> Right (s, a)
+  fa <*> a = Alex $ \s -> case unAlex fa s of
+                            Left msg -> Left msg
+                            Right (s', f) -> case unAlex a s' of
+                                               Left msg -> Left msg
+                                               Right (s'', b) -> Right (s'', f b)
+
 instance Monad Alex where
   m >>= k  = Alex $ \s -> case unAlex m s of 
                                 Left msg -> Left msg
-- 
2.2.1

From 9ef5ad7d8f11d833e363397294db1790482bee7d Mon Sep 17 00:00:00 2001
From: Reid Barton <rwbarton@gmail.com>
Date: Sat, 27 Sep 2014 14:19:39 -0400
Subject: [PATCH 2/2] Add Functor and Applicative instances for GHC 7.10
 compatibility

Commit 91b2b40136a77252617e50adeffdca7c5978337e added these to
the code generated by Alex, but not to Alex itself.
---
 src/NFA.hs        | 10 +++++++++-
 src/ParseMonad.hs | 10 ++++++++++
 2 files changed, 19 insertions(+), 1 deletion(-)

diff --git a/src/NFA.hs b/src/NFA.hs
index 81b0607..cfc80cb 100644
--- a/src/NFA.hs
+++ b/src/NFA.hs
@@ -23,7 +23,8 @@ import Map ( Map )
 import qualified Map hiding ( Map )
 import Util ( str, space )
 
-import Control.Monad ( forM_, zipWithM, zipWithM_, when )
+import Control.Applicative ( Applicative(..) )
+import Control.Monad ( forM_, zipWithM, zipWithM_, when, liftM, ap )
 import Data.Array ( Array, (!), array, listArray, assocs, bounds )
 
 -- Each state of a nondeterministic automaton contains a list of `Accept'
@@ -162,6 +163,13 @@ type MapNFA = Map SNum NState
 
 newtype NFAM a = N {unN :: SNum -> MapNFA -> Encoding -> (SNum, MapNFA, a)}
 
+instance Functor NFAM where
+  fmap = liftM
+
+instance Applicative NFAM where
+  pure  = return
+  (<*>) = ap
+
 instance Monad NFAM where
   return a = N $ \s n _ -> (s,n,a)
 
diff --git a/src/ParseMonad.hs b/src/ParseMonad.hs
index 9b22d06..b591973 100644
--- a/src/ParseMonad.hs
+++ b/src/ParseMonad.hs
@@ -19,6 +19,9 @@ import CharSet ( CharSet )
 import Map ( Map )
 import qualified Map hiding ( Map )
 import UTF8
+
+import Control.Applicative ( Applicative(..) )
+import Control.Monad ( liftM, ap )
 import Data.Word (Word8)
 -- -----------------------------------------------------------------------------
 -- The input type
@@ -84,6 +87,13 @@ data PState = PState {
 
 newtype P a = P { unP :: PState -> Either ParseError (PState,a) }
 
+instance Functor P where
+  fmap = liftM
+
+instance Applicative P where
+  pure  = return
+  (<*>) = ap
+
 instance Monad P where
  (P m) >>= k = P $ \env -> case m env of
 			Left err -> Left err
-- 
2.2.1

