--- mongoDB-1.3.0-orig/Database/MongoDB/Internal/Util.hs	2012-06-15 00:12:16.000000000 +1000
+++ mongoDB-1.3.0/Database/MongoDB/Internal/Util.hs	2012-09-15 20:55:51.173626267 +1000
@@ -97,7 +97,7 @@
 updateAssocs key valu assocs = case back of [] -> (key, valu) : front; _ : back' -> front ++ (key, valu) : back'
 	where (front, back) = break ((key ==) . fst) assocs
 
-bitOr :: (Bits a) => [a] -> a
+bitOr :: (Bits a, Num a) => [a] -> a
 -- ^ bit-or all numbers together
 bitOr = foldl (.|.) 0
 
--- mongoDB-1.3.0-orig/Database/MongoDB/Query.hs	2012-06-15 00:12:16.000000000 +1000
+++ mongoDB-1.3.0/Database/MongoDB/Query.hs	2012-10-20 18:29:34.159808907 +1100
@@ -1,6 +1,6 @@
 -- | Query and update documents
 
-{-# LANGUAGE OverloadedStrings, RecordWildCards, NamedFieldPuns, TupleSections, FlexibleContexts, FlexibleInstances, UndecidableInstances, MultiParamTypeClasses, GeneralizedNewtypeDeriving, StandaloneDeriving, TypeSynonymInstances, TypeFamilies #-}
+{-# LANGUAGE OverloadedStrings, RecordWildCards, NamedFieldPuns, TupleSections, FlexibleContexts, FlexibleInstances, UndecidableInstances, MultiParamTypeClasses, GeneralizedNewtypeDeriving, StandaloneDeriving, TypeSynonymInstances, TypeFamilies, CPP #-}
 
 module Database.MongoDB.Query (
 	-- * Monad
@@ -47,8 +47,13 @@
 import Data.Maybe (listToMaybe, catMaybes)
 import Data.Word (Word32)
 
+#if MIN_VERSION_base(4,6,0)
+import Control.Concurrent.MVar.Lifted (MVar, newMVar, mkWeakMVar,
+                                       readMVar, modifyMVar)
+#else
 import Control.Concurrent.MVar.Lifted (MVar, newMVar, addMVarFinalizer,
                                        readMVar, modifyMVar)
+#endif
 import Control.Monad.Base (MonadBase(liftBase))
 import Control.Monad.Error (ErrorT, Error(..), MonadError, runErrorT,
                             throwError)
@@ -508,7 +513,11 @@
 newCursor db col batchSize dBatch = do
 	var <- newMVar dBatch
 	let cursor = Cursor (db <.> col) batchSize var
+#if MIN_VERSION_base(4,6,0)
+	mkWeakMVar var (closeCursor cursor)
+#else
 	addMVarFinalizer var (closeCursor cursor)
+#endif
 	return cursor
 
 nextBatch :: (MonadIO m, MonadBaseControl IO m) => Cursor -> Action m [Document]
--- mongoDB-1.3.0-orig/System/IO/Pipeline.hs	2012-06-15 00:12:16.000000000 +1000
+++ mongoDB-1.3.0/System/IO/Pipeline.hs	2012-10-20 18:29:46.437108534 +1100
@@ -2,7 +2,7 @@
 
 A pipeline closes itself when a read or write causes an error, so you can detect a broken pipeline by checking isClosed.  It also closes itself when garbage collected, or you can close it explicitly. -}
 
-{-# LANGUAGE DoRec, RecordWildCards, NamedFieldPuns, ScopedTypeVariables #-}
+{-# LANGUAGE DoRec, RecordWildCards, NamedFieldPuns, ScopedTypeVariables, CPP #-}
 
 module System.IO.Pipeline (
 	IOE,
@@ -19,8 +19,13 @@
 import GHC.Conc (ThreadStatus(..), threadStatus)
 
 import Control.Monad.Trans (liftIO)
+#if MIN_VERSION_base(4,6,0)
+import Control.Concurrent.MVar.Lifted (MVar, newEmptyMVar, newMVar, withMVar,
+                                       putMVar, readMVar, mkWeakMVar)
+#else
 import Control.Concurrent.MVar.Lifted (MVar, newEmptyMVar, newMVar, withMVar,
                                        putMVar, readMVar, addMVarFinalizer)
+#endif
 import Control.Monad.Error (ErrorT(ErrorT), runErrorT)
 
 onException :: (Monad m) => ErrorT e m a -> m () -> ErrorT e m a
@@ -58,7 +63,11 @@
 	rec
 		let pipe = Pipeline{..}
 		listenThread <- forkIO (listen pipe)
+#if MIN_VERSION_base(4,6,0)
+	mkWeakMVar vStream $ do
+#else
 	addMVarFinalizer vStream $ do
+#endif
 		killThread listenThread
 		closeStream stream
 	return pipe
