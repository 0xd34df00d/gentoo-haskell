diff -urwpN ghc-6.4.1/ghc/driver/mangler/ghc-asm.lprl ghc-6.4.1.patched/ghc/driver/mangler/ghc-asm.lprl
--- ghc-6.4.1/ghc/driver/mangler/ghc-asm.lprl	2005-09-16 09:07:15.000000000 -0500
+++ ghc-6.4.1.patched/ghc/driver/mangler/ghc-asm.lprl	2006-04-03 13:11:11.000000000 -0500
@@ -88,7 +88,32 @@ exit(0);
 sub init_TARGET_STUFF {
 
     #--------------------------------------------------------#
-    if ( $TargetPlatform =~ /^alpha-.*-.*/ ) {
+    # cparrott: Linux/ALPHA is now ELF-based, not ECOFF-based, so a
+    # few things need to be changed here.
+    if ( $TargetPlatform =~ /^alpha-.*linux.*/ ) {
+
+    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
+    $T_US	    = ''; # _ if symbols have an underscore on the front
+    $T_PRE_APP	    = 'DONT THINK THIS APPLIES'; # regexp that says what comes before APP/NO_APP
+    $T_CONST_LBL    = '^\$L?C(\d+):$'; # regexp for what such a lbl looks like
+    $T_POST_LBL	    = ':';
+
+    $T_MOVE_DIRVS   = '^(\s*(\$.*\.\.ng:|\.align\s+\d+|\.(globl|ent)\s+\S+|\#.*|\.(file|loc)\s+\S+\s+\S+|\.text|\.r?data)\n)';
+    $T_COPY_DIRVS   = '^\s*(\$.*\.\.ng:|\#|\.(file|globl|ent|loc))';
+
+    $T_DOT_WORD	    = '\.(long|quad|byte|word)';
+    $T_DOT_GLOBAL   = '^\t\.globl';
+    $T_HDR_literal  = "\.text\n\t\.align 3\n";
+    $T_HDR_misc	    = "\.text\n\t\.align 3\n";
+    $T_HDR_data	    = "\.data\n\t\.align 3\n";
+    $T_HDR_rodata   = "\.text\n\t\.align 3\n";
+    $T_HDR_closure  = "\.data\n\t\.align 3\n";
+    $T_HDR_info	    = "\.text\n\t\.align 3\n";
+    $T_HDR_entry    = "\.text\n\t\.align 3\n";
+    $T_HDR_vector   = "\.text\n\t\.align 3\n";
+
+    #--------------------------------------------------------#
+    } elsif ( $TargetPlatform =~ /^alpha-.*-.*/ ) {
 
     $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
     $T_US	    = ''; # _ if symbols have an underscore on the front
@@ -1021,8 +1046,10 @@ sub mangle_asm {
 	# On Alphas, the prologue mangling is done a little later (below)
 
     	# toss all calls to __DISCARD__
+	# cparrott: the original match for alpha no longer works.  fixed.
 	$c =~ s/^\t(call|jbsr|jal)\s+${T_US}__DISCARD__\n//go;
-	$c =~ s/^\tjsr\s+\$26\s*,\s*${T_US}__DISCARD__\n//go if $TargetPlatform =~ /^alpha-/;
+        $c =~ s/^\tldq\s+\$27.*${T_US}__DISCARD__.*\n//go if $TargetPlatform =~ /^alpha-/;
+        $c =~ s/^\tjsr\s+\$26.*${T_US}__DISCARD__.*\n//go if $TargetPlatform =~  /^alpha-/;
 	$c =~ s/^\tbl\s+L___DISCARD__\$stub\n//go if $TargetPlatform =~ /^powerpc-apple-.*/;
 	$c =~ s/^\tbl\s+__DISCARD__(\@plt)?\n//go if $TargetPlatform =~ /^powerpc-.*-linux/;
 	$c =~ s/^\tbl\s+\.__DISCARD__\n\s+nop\n//go if $TargetPlatform =~ /^powerpc64-.*-linux/;
@@ -1241,6 +1268,16 @@ sub mangle_asm {
                 
 		# entry code will be put here!
 
+		# cparrott: on Alpha, we normally patch in .end
+		# directives at the end of the assembly code in the
+		# entry chunk immediately following this one.
+		# however, not all infotbl chunks are followed by
+		# a corresponding entry chunk.  we'll handle that
+		# special case here.
+		if ( $TargetPlatform =~ /^alpha-/ && !defined($entrychk{$symb}) ) {
+			print OUTASM "\t.end " . $symb . "_info\n";
+		}
+
 		$chkcat[$infochk{$symb}] = 'DONE ALREADY';
 	    }
 
@@ -1252,12 +1289,53 @@ sub mangle_asm {
 		# If this is an entry point with an info table,
                 # eliminate the entry symbol and all directives involving it.
 		if (defined($infochk{$symb}) && $TargetPlatform !~ /^ia64-/) {
+			# cparrott: existing match was broken on alpha, as it
+			# tossed out .globl directives for legitimate symbols!
+			# (e.g. .globl stg_dummy_ret should be tossed, but not
+			# .globl stg_dummy_ret_closure)
+			if ($TargetPlatform =~ /^alpha-/) {
+				$c =~ s/^.*$symb_(entry_ret)${T_POST_LBL}\n//;
+				$c =~ s/^\s*\..*$symb_(entry|ret)\n//g;
+			} else {
 			$c =~ s/^.*$symb_(entry|ret)${T_POST_LBL}\n//;
 			$c =~ s/^\s*\..*$symb.*\n//g;
 		}
+		}
 
 		print OUTASM $T_HDR_entry;
 
+		# cparrott: on Alpha, patch in .end directives at the
+		# end of the assembly code for this chunk, so the
+		# assembler will not complain.  this is hackish, as
+		# we can only guess where the end of the assembly
+		# code for the routine is.  it does not always
+		# correspond to the end of the chunk.
+		if ( defined($infochk{$symb}) && $TargetPlatform =~ /^alpha/ ) {
+			local($str) = "\t.end " . $symb . "_info";
+			local(@lines) = split(/\n/, $c);
+			local(@modifiedLines) = ();
+			local($seenPrologue) = 0;
+			local($addedEnd) = 0;
+			local($new_c) = '';
+			foreach (@lines) {
+				if ( $seenPrologue && !$addedEnd && /^\s*\..*/ ) {
+					push(@modifiedLines, $str);
+					$addedEnd = 1;
+				}
+				if ( /^\s*\.prologue/ ) {
+					$seenPrologue = 1;
+				}
+				push(@modifiedLines, $_);
+			}
+			if ( !$addedEnd ) {
+				push(@modifiedLines, $str);
+			}
+			foreach (@modifiedLines) {
+				$new_c .= $_ . "\n";
+			}
+			$c = $new_c;
+		}
+
 		&print_doctored($c, 1); # NB: the 1!!!
 
 		$chkcat[$entrychk{$symb}] = 'DONE ALREADY';
@@ -1587,7 +1665,7 @@ sub rev_tbl {
     if ( $TargetPlatform =~ /^alpha-/ && $label =~ /^([A-Za-z0-9_]+):$/) {
         local ($ident) = $1;
         $before =~ s/^((\s*\.(file|loc)\s+[^\n]*\n)*)/$1\t.ent $ident\n/;
-    	$after .= "\t.end $ident\n";
+#    	$after .= "\t.end $ident\n";  # cparrott: nope, broken
     }
 
     # Alphas: The heroic Simon Marlow found a bug in the Digital UNIX
@@ -1595,30 +1673,32 @@ sub rev_tbl {
     # first narrowed to 32 bits then sign-extended back to 64 bits.
     # This obviously screws up our 64-bit bitmaps, so we work around
     # the bug by replacing .quad with .align 3 + .long + .long [ccshan]
-    if ( $TargetPlatform =~ /^alpha-/ ) {
-	foreach (@words) {
-	    if (/^\s*\.quad\s+([-+0-9].*\S)\s*$/ && length $1 >= 10) {
-		local ($number) = $1;
-		if ($number =~ /^([-+])?(0x?)?([0-9]+)$/) {
-		    local ($sign, $base, $digits) = ($1, $2, $3);
-		    $base = (10, 8, 16)[length $base];
-		    local ($hi, $lo) = (0, 0);
-		    foreach $i (split(//, $digits)) {
-			$j = $lo * $base + $i;
-			$lo = $j % 4294967296;
-			$hi = $hi * $base + ($j - $lo) / 4294967296;
-		    }
-		    ($hi, $lo) = (4294967295 - $hi, 4294967296 - $lo)
-			if $sign eq "-";
-		    $_ = "\t.align 3\n\t.long $lo\n\t.long $hi\n";
-		    # printf STDERR "TURNING %s into 0x %08x %08x\n", $number, $hi, $lo;
-		} else {
-		    print STDERR "Cannot handle \".quad $number\" in info table\n";
-		    exit 1;
-		}
-	    }
-	}
-    }
+
+    # cparrott: apparently not necessary for Linux, seems buggy
+#    if ( $TargetPlatform =~ /^alpha-/ ) {
+#	foreach (@words) {
+#	    if (/^\s*\.quad\s+([-+0-9].*\S)\s*$/ && length $1 >= 10) {
+#		local ($number) = $1;
+#		if ($number =~ /^([-+])?(0x?)?([0-9]+)$/) {
+#		    local ($sign, $base, $digits) = ($1, $2, $3);
+#		    $base = (10, 8, 16)[length $base];
+#		    local ($hi, $lo) = (0, 0);
+#		    foreach $i (split(//, $digits)) {
+#			$j = $lo * $base + $i;
+#			$lo = $j % 4294967296;
+#			$hi = $hi * $base + ($j - $lo) / 4294967296;
+#		    }
+#		    ($hi, $lo) = (4294967295 - $hi, 4294967296 - $lo)
+#			if $sign eq "-";
+#		    $_ = "\t.align 3\n\t.long $lo\n\t.long $hi\n";
+#		    # printf STDERR "TURNING %s into 0x %08x %08x\n", $number, $hi, $lo;
+#		} else {
+#		    print STDERR "Cannot handle \".quad $number\" in info table\n";
+#		    exit 1;
+#		}
+#	    }
+#	}
+#    }
 
     $tbl = $before
 	 . (($TargetPlatform !~ /^hppa/) ? '' : join("\n", @imports) . "\n")
